# neural_shape_2
Еще одна нейронная сеть для распозавания фигур, имеет обводку. Точность - 95%.
Для начальной загрузки изображений использовалась библиотека pycairo, которая может записывать RGB изображения и простые геометрические фигуры в numpy-массивы. 
Сами результаты: 
Как видите, рамки обводки фигур не идеальны, но в большинстве случаев они находятся на нужном месте. Среднее значение IOU в тестовом наборе данных составляет около 0.4, что неплохо для распознавания трех объектов одновременно. Предсказанные формы и цвета (написанные над ограничивающими рамками) в значительной степени идеальны (точность - 95%+). По-видимому, сеть действительно научилась назначать предикторы различным объектам (так как мы использовали алгоритм перемешивания обучающих выборок). 
Были проделаны данные модификации:
1) Использовалась свёрточная нейронная сеть (CNN). CNN сканирует изображение с помощью обучаемых «фильтров» и извлекают все больше и больше абстрактных элементов на каждом слое. Фильтры в ранних слоях могут, например, обнаруживать края или цветовые градиенты, в то время как более поздние слои могут регистрировать сложные формы. Для результатов, показанных выше, сеть тренировалась четырьмя сверточными слоями и двумя пулами в течение примерно 30-40 минут. Более глубокая/более оптимизированная/более обученная сеть может, вероятно, получить лучшие результаты.
2) Использовалось не одно (двоичное) значение для классификации, а однозначные векторы (все 0 и 1 в индексе класса). В частности, использовался один вектор на объект для классификации формы (прямоугольник, треугольник или круг) и один вектор для классификации цвета (красный, зеленый или синий). Обратите внимание, что были добавлены некоторые случайные изменения к цветам во входных изображениях, чтобы посмотреть, сможет ли сеть справиться с этим. В целом, целевой вектор для изображения состоит из 10 значений для каждого объекта (4 для ограничивающего прямоугольника, 3 для классификации формы и 3 для классификации цвета).
3) Был адаптирован алгоритм перемешивания для работы с несколькими ограничивающими прямоугольниками (как упомянуто выше). После каждой эпохи алгоритм вычисляет среднеквадратичную ошибку для всех комбинаций одного предсказанного и одного ожидаемого ограничивающего прямоугольника. Затем он берет минимум этих значений, назначает друг другу соответствующие прогнозируемые и ожидаемые ограничивающие рамки, выбирает следующее наименьшее значение из box-ов, которые еще не были назначены, и так далее.

